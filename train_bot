import datetime
from datetime import date
from aiogram import Bot, Dispatcher, executor, types
import json
import urllib3
import station as stat
import aiohttp
import asyncio

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

token = '5349770843:AAHBhB-_mJYPr6w4DIGpl0mdMJU4A841duw'
yandex_api = "5d00a2a3-fdd0-4fcd-9da7-0c17e5f470e5"
bot = Bot(token)
dp = Dispatcher(bot)


async def fetch(session, url):
    async with session.get(url) as response:
        return await response.text()


async def fetch_all(session, urls, loop):
    results = await asyncio.gather(
        *[fetch(session, url) for url in urls],
        return_exceptions=True
    )
    return results


async def make_json(api_y: str, station_from, station_to):
    now = date.today()

    url = f'https://api.rasp.yandex.net/v3.0/search/?from={station_from}&to={station_to}&format=json&apikey={api_y}' \
          f'&lang=ru_RU&page=2&date={now}&system=yandex&limit=200'

    async with aiohttp.ClientSession() as session:
        response = await fetch(session, url)

    return json.loads(response)


async def find_train(data: json):
    now = datetime.datetime.now()
    now = now.isoformat()
    i = 0
    information = data["segments"][0]['departure']
    while information <= str(now):
        i += 1
        information = data["segments"][i]['departure']

    return information[11:16]


@dp.message_handler(commands=['start'])
async def start_menu(message: types.Message):
    start_message = "Привет, это бот, который поможет тебе успевать на электрички! \n" + \
                    "Чтобы узнать подробнее, воспользуйся командой /help"
    await message.reply(start_message)


@dp.message_handler(commands=['help'])
async def start_menu(message: types.Message):
    start_message = "Если хочешь узнать информацию про следующую электричку, воспользуйся командой /next"
    await message.reply(start_message)


@dp.message_handler(commands=['next'])
async def choose_station(message: types.Message):
    mes = "Выбери станцию, с которой отправляешься"
    keyboard = types.InlineKeyboardMarkup(row_width=2)
    button = types.InlineKeyboardButton("Новодачная", callback_data='nov')
    button1 = types.InlineKeyboardButton("Долгопрудная", callback_data='dolg')
    keyboard.add(button, button1)
    button = types.InlineKeyboardButton("Окружная", callback_data='circle')
    button1 = types.InlineKeyboardButton("Тимирязевская", callback_data='timka')
    keyboard.add(button, button1)
    button = types.InlineKeyboardButton("Савеловская", callback_data='savels')
    button1 = types.InlineKeyboardButton("Белорусская", callback_data='bel')
    keyboard.add(button, button1)

    await message.answer(mes, reply_markup=keyboard)


@dp.callback_query_handler(lambda c: True)
async def callback_inline(call):
    now_json = 0
    if call.data == 'nov':
        now_json = await make_json(yandex_api, stat.novodachka, stat.savela)
    elif call.data == 'dolg':
        now_json = await make_json(yandex_api, stat.dolgopa, stat.savela)
    elif call.data == 'circle':
        now_json = await make_json(yandex_api, stat.circle, stat.dolgopa)
    elif call.data == 'timka':
        now_json = await make_json(yandex_api, stat.timka, stat.dolgopa)
    elif call.data == 'savels':
        now_json = await make_json(yandex_api, stat.savela, stat.dolgopa)
    elif call.data == 'bel':
        now_json = await make_json(yandex_api, stat.bel, stat.dolgopa)
    mess = "Следующая электричка прибудет: \n"
    mess = mess + str(await find_train(now_json))
    await bot.send_message(call.message.chat.id, mess)


if __name__ == '__main__':
    executor.start_polling(dp)
